<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Learning Haskell the Hard Way | @h12</title>
<meta name="keywords" content="Haskell">
<meta name="description" content="When I was reading the collection of learning resources on Haskell and tried to find a good start, I quickly realized that
none of the books or tutorials are suitable for me: the easier a tutorial claims
to be, the harder to really understand Haskell by reading it. What I need is a
terse documentation that introduces the syntax and semantics of Haskell
systematically and clearly, but unfortunately none was found.">
<meta name="author" content="Hǎi-Liàng &#34;Hal&#34; Wáng">
<link rel="canonical" href="http://h12.io/article/learn-haskell/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.e79680cc8f2e2a0d9f078e6e22c427fd586eec7270ad113adecb066443cb0b97.css" integrity="sha256-55aAzI8uKg2fB45uIsQn/Vhu7HJwrRE63ssGZEPLC5c=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://h12.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://h12.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://h12.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://h12.io/apple-touch-icon.png">
<link rel="mask-icon" href="http://h12.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://h12.io/article/learn-haskell/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=PT+Sans+Narrow&family=PT+Serif:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/fontawesome.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/regular.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/brands.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />






<link id="syntax-mode" rel="stylesheet" href="/css/syntax-light.css">
<script>
    function isDarkMode() {
        const mode = localStorage.getItem("pref-theme");
        return (mode && mode === "dark") ||
            document.body.className.includes("dark") ||
            false;
    }

    function syncSyntaxMode() {
        document.getElementById("syntax-mode").href = isDarkMode() ? "/css/syntax-dark.css" : "/css/syntax-light.css";
    }

    document.addEventListener("DOMContentLoaded", () => {
        syncSyntaxMode();
        const toggleButton = document.getElementById("theme-toggle");
        if (!toggleButton) {
            console.log("No toggle button found");
            return;
        }
        toggleButton.addEventListener("click", syncSyntaxMode);
    });
</script>







<meta property="og:url" content="http://h12.io/article/learn-haskell/">
  <meta property="og:site_name" content="@h12">
  <meta property="og:title" content="Learning Haskell the Hard Way">
  <meta property="og:description" content="When I was reading the collection of learning resources on Haskell and tried to find a good start, I quickly realized that none of the books or tutorials are suitable for me: the easier a tutorial claims to be, the harder to really understand Haskell by reading it. What I need is a terse documentation that introduces the syntax and semantics of Haskell systematically and clearly, but unfortunately none was found.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="article">
    <meta property="article:published_time" content="2014-07-26T08:12:39+00:00">
    <meta property="article:modified_time" content="2014-07-26T08:12:39+00:00">
    <meta property="article:tag" content="Haskell">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Learning Haskell the Hard Way">
<meta name="twitter:description" content="When I was reading the collection of learning resources on Haskell and tried to find a good start, I quickly realized that
none of the books or tutorials are suitable for me: the easier a tutorial claims
to be, the harder to really understand Haskell by reading it. What I need is a
terse documentation that introduces the syntax and semantics of Haskell
systematically and clearly, but unfortunately none was found.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Articles",
      "item": "http://h12.io/article/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Learning Haskell the Hard Way",
      "item": "http://h12.io/article/learn-haskell/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Learning Haskell the Hard Way",
  "name": "Learning Haskell the Hard Way",
  "description": "When I was reading the collection of learning resources on Haskell and tried to find a good start, I quickly realized that none of the books or tutorials are suitable for me: the easier a tutorial claims to be, the harder to really understand Haskell by reading it. What I need is a terse documentation that introduces the syntax and semantics of Haskell systematically and clearly, but unfortunately none was found.\n",
  "keywords": [
    "Haskell"
  ],
  "articleBody": "When I was reading the collection of learning resources on Haskell and tried to find a good start, I quickly realized that none of the books or tutorials are suitable for me: the easier a tutorial claims to be, the harder to really understand Haskell by reading it. What I need is a terse documentation that introduces the syntax and semantics of Haskell systematically and clearly, but unfortunately none was found.\nI know I have to try the hard way: reading the Haskell language specification directly and absorb it myself. To make the process less dull and record my progress, I will write down my learning notes here incrementally.\nOverview A Haskell program is organized with four levels: modules, declarations, expressions \u0026 lexical structures, but the specification is organized in the reverse order.\nHaskell has ad hoc polymorphism (overloading) and parametric polymorphism (Hindley-Milner type structure).\nHaskell has six namespaces:\nfor value variable constructor for type entity type variable type constructor type class module The same name can be reused without conflicts as long as they are in different namespaces.\nLexical Structure A Haskell program is composed of lexemes (tokens) and whitespaces.\nprogram → { lexeme | whitespace } Whitespace includes:\nThe complete set of whitespace in both ASCII \u0026 Unicode Two kinds of comments inline comment starts with -- nested comment wrapped by {- -} A lexeme is one of the following:\nidentifier qvarid: (qualified) variable identifier qconid: (qualified) constructor identifier reservedid: reserved identifier operator qvarsym: (qualified) variable (symbolic) operator qconsym: (qualified) constructor (symbolic) operator reservedop: reserved operator literal: integer, float, character or string literal special: one of special symbols ()[]{}`,; A variable and a constructor is distinguished by the first character and put into different namespaces:\nidentifier variable: lower case (including underscore) constructor: upper case operator variable: non-colon constructor: colon : A variable or constructor can contain symbol ', so the common mathematical term “x prime” can be represented as x'.\nBy using layout rule (indentation), symbols {}; can be omitted in sereral grammer productions.\nExpressions Parentheses (exp) is a parenthesized expression, and is equivalent to exp.\nFunction \u0026 operator application Function is prefixed and curried, so f x y means (f x) y.\nfexp → [fexp] aexp All operators are infixed except prefix negation -.\ninfixexp→ lexp qop infixexp | - infixexp (prefix negation) | lexp qop → qvarop | qconop An operator can be converted to prefix notation by parentheses. e.g.\n(+) x y Reversely, a function identifier (either variable or constructor) can be converted to an infix operator by backquotes.\nx `op` y List \u0026 Tuple List is constructed with :.\n1:2:3:[] or (:) 1 ((:) 2 ((:) 3 [])) Arithmetic sequence is another way to construct a list.\n[1,3..6] == [1,3,5] [1..6] == [1,2,3,4,5,6] Tuple is constructed with (,...,).\n(1, 2, \"a\") or (,,) 1 2 \"a\" Field label A field label is used to give a name to a field in a datatype. It can be used to construct, extract and update the field.\nA constructor with labeled fields:\naexp → qcon { fbind1 , … , fbindn } (n ≥ 0) fbind → qvar = exp Pattern matching A pattern itself is not an expression, but it is an important part of sereral expressions, including: lambda abstractions, function definitions, let expressions, list comprehensions, do expressions and case expressions.\nPattern matching is used to deconstruct values according to their type specification. It proceeds from left to right, and outside to inside. Attempting to match a pattern can have one of three results:\nFail Succeed: returning a binding for each variable in the pattern Diverge: i.e. return ⊥ The syntax for patterns covers a subset of expressions.\nA pattern can match against infix expressions, but limited to infix constructors (the operator must be qconop).\npat → lpat qconop pat (infix constructor) A pattern can match against constructor functions (with or without field labels).\npat → ... | lpat lpat → apat | gcon apat1 … apatk (arity gcon = k, k ≥ 1) apat → ... | gcon (arity gcon = 0) | qcon { fpat1 , … , fpatk } (labeled pattern, k ≥ 0) fpat → qvar = pat A pattern can match against a variable, a literal, a parenthesized expression, a tuple or a list.\nlpat → var ... | - (integer | float) (negative literal) apat → ... | literal | ( pat ) (parenthesized pattern) | ( pat1 , … , patk ) (tuple pattern, k ≥ 2) | [ pat1 , … , patk ] (list pattern, k ≥ 1) The variables defined within the pattern can be binded, but how to name and bind the whole pattern? This is exactly what an as pattern does (var before @ is the name for the whole pattern).\napat → var [ @ apat] (as pattern) Wildcard is used when you need a variable placeholder but do not want to bind the value to a name.\napat → ... | _ (wildcard) Sometimes you need a pattern that can never fail (only succeed or diverge), it is called a irrefutable pattern.\napat → ... | ~ apat (irrefutable pattern) Besides ~apat, these patterns are also irrefutable: a variable, a wildcard, N apat where N is a constructor defined by newtype and apat is irrefutable, var@apat where apat is irrefutable. All other patterns are refutable.\nCase expression Case expression is very important because all other pattern matching expressions ultimately translate into case expressions.\nA case expression has one or more alternatives.\nlexp → case exp of { alts } alts → alt1 ; … ; altn (n ≥ 1) An alternative is either a pattern or empty. The pattern either coresponds to an expression (body) directly, or has one or more guarded patterns (note an optional gdpat appears at the right side of itself). A guarded pattern starts with | and is composed of one or more guards.\nalt → pat -\u003e exp [where decls] | pat gdpat [where decls] | (empty alternative) gdpat → guards -\u003e exp [ gdpat ] guards → | guard1, …, guardn (n ≥ 1) decls → { decl1 ; … ; decln } (n ≥ 0) Note that each alternative can optionally have a where declaration. It is used to bind extra variables to be used in the local scope.\nThere are two types of guards: pattern guard \u0026 boolean guard, and local declarations can also be introduced together with guards.\nguard → pat \u003c- infixexp (pattern guard) | let decls (local declaration) | infixexp (boolean guard) This is how a case expression works:\nThe expression after case is matched against each alternative till a match is found. Then each guarded pattern in the matched alterantive is tested till one passes. A guarded pattern passes if and only if all of its guards pass. If successful, the conresponding expression is returned, otherwise, the next guarded pattern or alternative is tried sequentially. If no match can be found, the result is ⊥. Lambda expression Lambda is used to construct a function without a name. Besides a variable, the input can also be any pattern.\nlexp → \\ apat1 … apatn -\u003e exp (n ≥ 1) An example:\n(\\ (x, y) -\u003e x+y) (3, 7) Also note that lambda -\u003e associates to the right, e.g.\nInteger -\u003e Integer -\u003e Integer is equivalent to Integer -\u003e (Integer -\u003e Integer) Let expression A let expression introduces a nested, lexically-scoped, mutually-recursive list of declarations. exp after keyword in is the value of a let expression.\nlexp → let decls in exp decls → { decl1 ; … ; decln } (n ≥ 0) Some examples:\nlet {} in 42 let {(x,y) = (1,2)} in x+y List comprehension A list comprehension constructs a list of elements represented by exp qualified by one or more qualifiers.\naexp → [ exp | qual1 , … , qualn ] (n ≥ 1) There are three kinds of qualifiers.\nA generator is composed of a pattern (pat with type t) and a list (e with type [t]). The pattern is matched against and binded to each element of the list one by one, so the binded variables can be used to generate each element of the result list. The generators are evaluated in a nested, depth-first order, and a failed match is just skipped over.\nqual → pat \u003c- e (generator) A qualifier can also be a local declaration to bind auxiliary variables, or a boolean guard to exclude some elements from the list.\nqual → ... | let decls (local declaration) | exp (boolean guard) Do expression Wait till monad is fully understood.\nType signature Haskell has type inference, but an expression can be optionally specified with a type signature.\nexp → infixexp :: [context =\u003e] type Declarations There are top declarations (topdecl) that are only allowed at the top level of a module, and nested declarations (decl) that may be used either at the top level or in nested scopes.\ntopdecl → ... | ... | decl Top declarations A top declaration starts with one of the keywords: data, type, newtype, class, instance, default and foreign.\ndata, type and newtype is for declaring new types. class is for declaring typeclasses and instance is for declaring the membership between types and typeclasses.\nThey are explained later one by one.\nNested declarations In the last section, decl appears in the let expression and where clause without any explanations. Actually, they are nested declarations.\nThere are five kinds of nested declarations: type signature, fixity, function binding, pattern binding and empty declartions.\nA type signature simply specifies types for variables.\ndecl → gendecl | ... gendecl → vars :: [context =\u003e] type vars → var1 , …, varn (n ≥ 1) A fixity declaration gives the fixity and binding precedence of one or more operators.\ngendecl → ... | fixity [integer] ops fixity → infixl | infixr | infix ops → op1 , … , opn (n ≥ 1) op → varop | conop The right hand side (rhs) of function and pattern bindings are the same.\ndecl → ... | (funlhs | pat) rhs The syntax of rhs is almost the same as case expression, except -\u003e is replaced by =.\nrhs → = exp [where decls] | gdrhs [where decls] gdrhs → guards = exp [gdrhs] A function can be binded in multiple function binding declarations, as long as they are contiguous and the number of patterns is the same. In each of the declaration, the left hand side supports three alternative syntaxes.\nfunlhs → var apat { apat } | pat varop pat | ( funlhs ) apat { apat } And an example:\nplus x y z = x+y+z x ‘plus‘ y = \\ z -\u003e x+y+z (x ‘plus‘ y) z = x+y+z Type Just as an expression may contain variables and denotes a value, a type expression may contain type variables and denotes a type value (but it is evaluated at compile time, unlike an expression evaluated at run time).\nType expressions are designed to have similar representations as their corresponding expressions.\nFunction type can be represented in infix or prefix notation. Like function application, type application (btype) is also prefixed and curried. atype is the type expression excluding infix function type and type application.\ntype → btype [-\u003e type] (function type) btype → [btype] atype (type application) atype → gtycon | ... gtycon → ... | (-\u003e) (function constructor) A type variable is an identifier beginning with a lowercase letter. A parenthesized type (t) is identical to the type t. A type constructor (type template) as an identifier begins with an uppercase letter. Besides function type, the syntaxes for tuple and list are also special syntaxes.\natype → gtycon | tyvar | ( type1 , … , typek ) (tuple type, k ≥ 2) | [ type ] (list type) | ( type ) (parenthesised constructor) gtycon → qtycon | () (unit type) | [] (list constructor) | (-\u003e) (function constructor) | (,{,}) (tupling constructors) Kind What is *, * -\u003e *…? An ordinary type has kind *. A type constructor (template) that has one type argument has kind * -\u003e *, e.g. a list. So on and so forth.\nContext The context (context =\u003e type) is used to indicate that type tyvar belongs to class qtycls.\nA context is composed of zero or more class assertions.\ncontext → class | ( class1 , … , classn ) (n ≥ 0) And a class assertion is either either a type variable, or the application of type variable to one or more types.\nclass → qtycls tyvar | qtycls ( tyvar atype1 … atypen ) (n ≥ 1) qtycls → [ modid . ] tycls tycls → conid tyvar → varid Algebraic data type algebraic data type is named so because it is composed of other types by product and sum (algebraic operations). It introduces a new type constructor (simpletype) with zero or more constituent data constructors (constrs).\ntopdecl → ... | data [context =\u003e] simpletype [= constrs] [deriving] The type constructor begins with upper case letter and may have zero to more type variables as parameters. The type constructor then can be used in curried type application in a type expression.\nsimpletype → tycon tyvar1 … tyvark (k ≥ 0) On the right side of =, sum (alternative) types are separated by |.\nconstrs → constr1 | … | constrn (n ≥ 1) For each constr, there are three alternative syntaxes.\nA data constructor followed by zero or more atype. An infix data constructor operator between two btype. A data constructor followed by field declarations. constr → con [!] atype1 … [!] atypek (arity con = k, k ≥ 0) | (btype | ! atype) conop (btype | ! atype) (infix conop) | con { fielddecl1 , … , fielddecln } (n ≥ 0) con → conid | ( consym ) (constructor) ! is strictness flag to indicate that the corresponding constructor argument is eagerly evaluated.\nType synonym A type synonym is equivalent to its definition are completely interchangeable.\ntopdecl → type simpletype = type Newtype A newtype declaration introduces a distinct type whose representation is the same as an existing type.\ntopdecl → newtype [context =\u003e] simpletype = newconstr [deriving] newconstr → con atype | con { var :: type } Unlike type synonyms, newtype may be used to define recursive types. New instances can be defined for a type defined by newtype but may not be defined for a type synonym. A type created by newtype has an extra level of indirection compared to an algebraic datatype, so the pattern matching rule is different. Ad hoc polymorphism Ad hoc polymorphism (overloading) is supported by typeclasses.\nA class declaration introduces a new class and the operations (methods) on it.\nModules To be continued…\n",
  "wordCount" : "2472",
  "inLanguage": "en",
  "datePublished": "2014-07-26T08:12:39Z",
  "dateModified": "2014-07-26T08:12:39Z",
  "author":{
    "@type": "Person",
    "name": "Hǎi-Liàng \"Hal\" Wáng"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://h12.io/article/learn-haskell/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "@h12",
    "logo": {
      "@type": "ImageObject",
      "url": "http://h12.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://h12.io/" accesskey="h" title="@h12 (Alt + H)">@h12</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://h12.io/article/" title="Articles">
                    <span><i class="fas fa-newspaper"></i> Articles</span>
                </a>
            </li>
            <li>
                <a href="http://h12.io/project/" title="Projects">
                    <span><i class="fab fa-github"></i> Projects</span>
                </a>
            </li>
            <li>
                <a href="http://h12.io/note/" title="Notes">
                    <span><i class="fas fa-sticky-note"></i> Notes</span>
                </a>
            </li>
            <li>
                <a href="http://h12.io/about/" title="About">
                    <span><i class="fas fa-user"></i> About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
 



    <h1 class="post-title entry-hint-parent">
      Learning Haskell the Hard Way
    </h1>
    <div class="post-meta"><span title='2014-07-26 08:12:39 +0000 UTC'>July 26, 2014</span>

</div>
  </header> 
  <div class="post-content"><p>When I was reading the <a href="http://www.haskell.org/haskellwiki/Learning_Haskell">collection</a> of learning resources on Haskell and tried to find a good start, I quickly realized that
none of the books or tutorials are suitable for me: the easier a tutorial claims
to be, the harder to really understand Haskell by reading it. What I need is a
terse documentation that introduces the syntax and semantics of Haskell
systematically and clearly, but unfortunately none was found.</p>
<p>I know I have to try the hard way: reading the
<a href="http://www.haskell.org/haskellwiki/Language_and_library_specification">Haskell language specification</a>
directly and absorb it myself. To make the process less dull and record my
progress, I will write down my learning notes here incrementally.</p>
<h2 id="overview">Overview<a hidden class="anchor" aria-hidden="true" href="#overview">#</a></h2>
<p>A Haskell program is organized with four levels: <em>modules</em>, <em>declarations</em>,
<em>expressions</em> &amp; <em>lexical structures</em>, but the specification is organized in the
reverse order.</p>
<p>Haskell has <em>ad hoc</em> polymorphism (<em>overloading</em>) and <em>parametric</em> polymorphism
(Hindley-Milner type structure).</p>
<p>Haskell has six namespaces:</p>
<ul>
<li>for value
<ul>
<li>variable</li>
<li>constructor</li>
</ul>
</li>
<li>for type entity
<ul>
<li>type variable</li>
<li>type constructor</li>
<li>type class</li>
</ul>
</li>
<li>module</li>
</ul>
<p>The same name can be reused without conflicts as long as they are in different
namespaces.</p>
<h2 id="lexical-structure">Lexical Structure<a hidden class="anchor" aria-hidden="true" href="#lexical-structure">#</a></h2>
<p>A Haskell program is composed of lexemes (tokens) and whitespaces.</p>
<pre tabindex="0"><code>program → { lexeme | whitespace } 
</code></pre><p>Whitespace includes:</p>
<ul>
<li>The complete set of whitespace in both ASCII &amp; Unicode</li>
<li>Two kinds of comments
<ul>
<li>inline comment starts with <code>--</code></li>
<li>nested comment wrapped by <code>{- -}</code></li>
</ul>
</li>
</ul>
<p>A lexeme is one of the following:</p>
<ul>
<li>identifier
<ul>
<li>qvarid: (qualified) variable identifier</li>
<li>qconid: (qualified) constructor identifier</li>
<li>reservedid: reserved identifier</li>
</ul>
</li>
<li>operator
<ul>
<li>qvarsym: (qualified) variable (symbolic) operator</li>
<li>qconsym: (qualified) constructor (symbolic) operator</li>
<li>reservedop: reserved operator</li>
</ul>
</li>
<li>literal: integer, float, character or string literal</li>
<li>special: one of special symbols <code>()[]{}`,;</code></li>
</ul>
<p>A variable and a constructor is distinguished by the first character and put into
different namespaces:</p>
<ul>
<li>identifier
<ul>
<li>variable: lower case (including underscore)</li>
<li>constructor: upper case</li>
</ul>
</li>
<li>operator
<ul>
<li>variable: non-colon</li>
<li>constructor: colon <code>:</code></li>
</ul>
</li>
</ul>
<p>A variable or constructor can contain symbol <code>'</code>, so the common mathematical
term &ldquo;x prime&rdquo; can be represented as <code>x'</code>.</p>
<p>By using layout rule (indentation), symbols <code>{};</code> can be omitted in sereral
grammer productions.</p>
<h2 id="expressions">Expressions<a hidden class="anchor" aria-hidden="true" href="#expressions">#</a></h2>
<h3 id="parentheses">Parentheses<a hidden class="anchor" aria-hidden="true" href="#parentheses">#</a></h3>
<p><code>(exp)</code> is a <em>parenthesized expression</em>, and is equivalent to <code>exp</code>.</p>
<h3 id="function--operator-application">Function &amp; operator application<a hidden class="anchor" aria-hidden="true" href="#function--operator-application">#</a></h3>
<p>Function is prefixed and curried, so <code>f x y</code> means <code>(f x) y</code>.</p>
<pre tabindex="0"><code>fexp    → [fexp] aexp
</code></pre><p>All operators are infixed except prefix negation <code>-</code>.</p>
<pre tabindex="0"><code>infixexp→ lexp qop infixexp
        | - infixexp    (prefix negation)
        | lexp
qop     → qvarop | qconop
</code></pre><p>An operator can be converted to prefix notation by parentheses. e.g.</p>
<pre tabindex="0"><code>(+) x y
</code></pre><p>Reversely, a function identifier (either variable or constructor) can be
converted to an infix operator by backquotes.</p>
<pre tabindex="0"><code>x `op` y
</code></pre><h3 id="list--tuple">List &amp; Tuple<a hidden class="anchor" aria-hidden="true" href="#list--tuple">#</a></h3>
<p>List is constructed with <code>:</code>.</p>
<pre tabindex="0"><code>1:2:3:[]   or   (:) 1 ((:) 2 ((:) 3 []))
</code></pre><p><em>Arithmetic sequence</em> is another way to construct a list.</p>
<pre tabindex="0"><code>[1,3..6] == [1,3,5]
  [1..6] == [1,2,3,4,5,6]
</code></pre><p>Tuple is constructed with <code>(,...,)</code>.</p>
<pre tabindex="0"><code>(1, 2, &#34;a&#34;)   or   (,,) 1 2 &#34;a&#34;
</code></pre><h3 id="field-label">Field label<a hidden class="anchor" aria-hidden="true" href="#field-label">#</a></h3>
<p>A field label is used to give a name to a field in a datatype. It can be used to
construct, extract and update the field.</p>
<p>A constructor with labeled fields:</p>
<pre tabindex="0"><code>aexp    → qcon { fbind1 , … , fbindn }  (n ≥ 0)
fbind   → qvar = exp 
</code></pre><h3 id="pattern-matching">Pattern matching<a hidden class="anchor" aria-hidden="true" href="#pattern-matching">#</a></h3>
<p>A pattern itself is not an expression, but it is an important part of sereral
expressions, including: <em>lambda abstractions</em>, <em>function definitions</em>,
<em>let expressions</em>, <em>list comprehensions</em>, <em>do expressions</em> and <em>case expressions</em>.</p>
<p>Pattern matching is used to deconstruct values according to their type
specification. It proceeds from left to right, and outside to inside. Attempting
to match a pattern can have one of three results:</p>
<ul>
<li>Fail</li>
<li>Succeed: returning a binding for each variable in the pattern</li>
<li>Diverge: i.e. return ⊥</li>
</ul>
<p>The syntax for patterns covers a subset of expressions.</p>
<p>A pattern can match against infix expressions, but limited to infix constructors
(the operator must be <code>qconop</code>).</p>
<pre tabindex="0"><code>pat     → lpat qconop pat (infix constructor)
</code></pre><p>A pattern can match against constructor functions (with or without field labels).</p>
<pre tabindex="0"><code>pat     → ...
        | lpat

lpat    → apat
        | gcon apat1 … apatk    (arity gcon  =  k, k ≥ 1) 

apat    → ...
        | gcon  (arity gcon  =  0)
        | qcon { fpat1 , … , fpatk }    (labeled pattern, k ≥ 0)

fpat    → qvar = pat 
</code></pre><p>A pattern can match against a variable, a literal, a parenthesized expression,
a tuple or a list.</p>
<pre tabindex="0"><code>lpat    → var ...
        | - (integer | float)   (negative literal) 

apat    → ...
        | literal
        | ( pat )               (parenthesized pattern)
        | ( pat1 , … , patk )   (tuple pattern, k ≥ 2)
        | [ pat1 , … , patk ]   (list pattern, k ≥ 1)
</code></pre><p>The variables defined within the pattern can be binded, but how to name and bind
the whole pattern? This is exactly what an <em>as pattern</em> does (<code>var</code> before <code>@</code>
is the name for the whole pattern).</p>
<pre tabindex="0"><code>apat    → var [ @ apat] (as pattern) 
</code></pre><p>Wildcard is used when you need a variable placeholder but do not want to bind
the value to a name.</p>
<pre tabindex="0"><code>apat    → ...
        | _     (wildcard)
</code></pre><p>Sometimes you need a pattern that can never fail (only succeed or diverge), it
is called a irrefutable pattern.</p>
<pre tabindex="0"><code>apat    → ...
        | ~ apat        (irrefutable pattern)
</code></pre><p>Besides <code>~apat</code>, these patterns are also irrefutable: a variable, a wildcard,
<code>N apat</code> where N is a constructor defined by newtype and apat is irrefutable,
<code>var@apat</code> where apat is irrefutable. All other patterns are refutable.</p>
<h3 id="case-expression">Case expression<a hidden class="anchor" aria-hidden="true" href="#case-expression">#</a></h3>
<p>Case expression is very important because all other pattern matching expressions
ultimately translate into case expressions.</p>
<p>A case expression has one or more alternatives.</p>
<pre tabindex="0"><code>lexp    → case exp of { alts }
alts    → alt1 ; … ; altn       (n ≥ 1) 
</code></pre><p>An alternative is either a pattern or empty. The pattern either coresponds to
an expression (body) directly, or has one or more guarded patterns (note an
optional gdpat appears at the right side of itself). A guarded pattern starts
with <code>|</code> and is composed of one or more guards.</p>
<pre tabindex="0"><code>alt     → pat -&gt; exp [where decls]
        | pat  gdpat [where decls]
        | (empty alternative) 
gdpat   → guards -&gt; exp [ gdpat ]
guards  → | guard1, …, guardn   (n ≥ 1)
decls   → { decl1 ; … ; decln } (n ≥ 0) 
</code></pre><p>Note that each alternative can optionally have a <code>where</code> declaration. It is used
to bind extra variables to be used in the local scope.</p>
<p>There are two types of guards: <em>pattern guard</em> &amp; <em>boolean guard</em>, and local
declarations can also be introduced together with guards.</p>
<pre tabindex="0"><code>guard   → pat &lt;- infixexp     (pattern guard)
        | let decls           (local declaration)
        | infixexp            (boolean guard)
</code></pre><p>This is how a case expression works:</p>
<ol>
<li>The expression after <code>case</code> is matched against each alternative till a match
is found.</li>
<li>Then each guarded pattern in the matched alterantive is tested till one
passes. A guarded pattern passes if and only if all of its guards pass.</li>
<li>If successful, the conresponding expression is returned, otherwise, the next
guarded pattern or alternative is tried sequentially.</li>
<li>If no match can be found, the result is ⊥.</li>
</ol>
<h3 id="lambda-expression">Lambda expression<a hidden class="anchor" aria-hidden="true" href="#lambda-expression">#</a></h3>
<p>Lambda is used to construct a function without a name. Besides a variable, the
input can also be any pattern.</p>
<pre tabindex="0"><code>lexp    → \ apat1 … apatn -&gt; exp        (n ≥ 1)
</code></pre><p>An example:</p>
<pre tabindex="0"><code>(\ (x, y) -&gt; x+y) (3, 7)
</code></pre><p>Also note that lambda <code>-&gt;</code> associates to the right, e.g.</p>
<pre tabindex="0"><code>Integer -&gt;  Integer -&gt; Integer
    is equivalent to
Integer -&gt; (Integer -&gt; Integer)
</code></pre><h3 id="let-expression">Let expression<a hidden class="anchor" aria-hidden="true" href="#let-expression">#</a></h3>
<p>A let expression introduces a nested, lexically-scoped, mutually-recursive list
of declarations. <code>exp</code> after keyword <code>in</code> is the value of a let expression.</p>
<pre tabindex="0"><code>lexp    → let decls in exp
decls   → { decl1 ; … ; decln } (n ≥ 0) 
</code></pre><p>Some examples:</p>
<pre tabindex="0"><code>let {} in 42
let {(x,y) = (1,2)} in x+y
</code></pre><h3 id="list-comprehension">List comprehension<a hidden class="anchor" aria-hidden="true" href="#list-comprehension">#</a></h3>
<p>A list comprehension constructs a list of elements represented by <code>exp</code> qualified
by one or more qualifiers.</p>
<pre tabindex="0"><code>aexp    → [ exp | qual1 , … , qualn ]   (n ≥ 1)
</code></pre><p>There are three kinds of qualifiers.</p>
<p>A generator is composed of a pattern (<code>pat</code> with type <code>t</code>) and a list (<code>e</code> with
type <code>[t]</code>). The pattern is matched against and binded to each element of the
list one by one, so the binded variables can be used to generate each element of
the result list. The generators are evaluated in a nested, depth-first order,
and a failed match is just skipped over.</p>
<pre tabindex="0"><code>qual    → pat &lt;- e      (generator)
</code></pre><p>A qualifier can also be a local declaration to bind auxiliary variables, or a
boolean guard to exclude some elements from the list.</p>
<pre tabindex="0"><code>qual    → ...
        | let decls     (local declaration)
        | exp           (boolean guard) 
</code></pre><h3 id="do-expression">Do expression<a hidden class="anchor" aria-hidden="true" href="#do-expression">#</a></h3>
<p><em>Wait till monad is fully understood.</em></p>
<h3 id="type-signature">Type signature<a hidden class="anchor" aria-hidden="true" href="#type-signature">#</a></h3>
<p>Haskell has type inference, but an expression can be optionally specified with a
<em>type signature</em>.</p>
<pre tabindex="0"><code>exp     → infixexp :: [context =&gt;] type
</code></pre><h2 id="declarations">Declarations<a hidden class="anchor" aria-hidden="true" href="#declarations">#</a></h2>
<p>There are top declarations (<code>topdecl</code>) that are only allowed at the top level of
a module, and nested declarations (<code>decl</code>) that may be used either at the top
level or in nested scopes.</p>
<pre tabindex="0"><code>topdecl → ...
        | ...
        | decl 
</code></pre><h3 id="top-declarations">Top declarations<a hidden class="anchor" aria-hidden="true" href="#top-declarations">#</a></h3>
<p>A top declaration starts with one of the keywords: <code>data</code>, <code>type</code>, <code>newtype</code>,
<code>class</code>, <code>instance</code>, <code>default</code> and <code>foreign</code>.</p>
<p><code>data</code>, <code>type</code> and <code>newtype</code> is for declaring new types. <code>class</code> is for
declaring typeclasses and <code>instance</code> is for declaring the membership between
types and typeclasses.</p>
<p>They are explained later one by one.</p>
<h3 id="nested-declarations">Nested declarations<a hidden class="anchor" aria-hidden="true" href="#nested-declarations">#</a></h3>
<p>In the last section, <code>decl</code> appears in the let expression and where clause
without any explanations. Actually, they are nested declarations.</p>
<p>There are five kinds of nested declarations: <em>type signature</em>, <em>fixity</em>,
<em>function binding</em>, <em>pattern binding</em> and <em>empty</em> declartions.</p>
<p>A <em>type signature</em> simply specifies types for variables.</p>
<pre tabindex="0"><code>decl    → gendecl
        | ...
gendecl → vars :: [context =&gt;] type
vars    → var1 , …, varn        (n ≥ 1)
</code></pre><p>A <em>fixity</em> declaration gives the fixity and binding precedence of one or more
operators.</p>
<pre tabindex="0"><code>gendecl → ...
        | fixity [integer] ops
fixity  → infixl | infixr | infix
ops     → op1 , … , opn         (n ≥ 1)
op      → varop | conop 
</code></pre><p>The right hand side (<code>rhs</code>) of function and pattern bindings are the same.</p>
<pre tabindex="0"><code>decl    → ...
        | (funlhs | pat) rhs
</code></pre><p>The syntax of <code>rhs</code> is almost the same as <em>case expression</em>, except <code>-&gt;</code> is
replaced by <code>=</code>.</p>
<pre tabindex="0"><code>rhs     → = exp [where decls]
        | gdrhs [where decls]
gdrhs   → guards = exp [gdrhs]
</code></pre><p>A function can be binded in multiple function binding declarations, as long as
they are contiguous and the number of patterns is the same. In each of the
declaration, the left hand side supports three alternative syntaxes.</p>
<pre tabindex="0"><code>funlhs  → var apat { apat }
        | pat varop pat
        | ( funlhs ) apat { apat }
</code></pre><p>And an example:</p>
<pre tabindex="0"><code>plus x y z = x+y+z
x ‘plus‘ y = \ z -&gt; x+y+z
(x ‘plus‘ y) z = x+y+z
</code></pre><h3 id="type">Type<a hidden class="anchor" aria-hidden="true" href="#type">#</a></h3>
<p>Just as an <em>expression</em> may contain variables and denotes a value, a
<em>type expression</em> may contain <em>type variables</em> and denotes a type value (but it
is evaluated at compile time, unlike an expression evaluated at run time).</p>
<p>Type expressions are designed to have similar representations as their
corresponding expressions.</p>
<p>Function type can be represented in infix or prefix notation.
Like function application, <em>type application</em> (<code>btype</code>) is also prefixed and
curried. <code>atype</code> is the type expression excluding infix function type and
type application.</p>
<pre tabindex="0"><code>type    → btype [-&gt; type]       (function type)
btype   → [btype] atype         (type application)
atype   → gtycon
        | ...
gtycon  → ...
        | (-&gt;)  (function constructor)
</code></pre><p>A <em>type variable</em> is an identifier beginning with a lowercase letter.
A <em>parenthesized type</em> <code>(t)</code> is identical to the type <code>t</code>.
A <em>type constructor</em> (type template) as an identifier begins with an uppercase
letter.
Besides function type, the syntaxes for tuple and list are also special syntaxes.</p>
<pre tabindex="0"><code>atype   → gtycon
        | tyvar
        | ( type1 , … , typek ) (tuple type, k ≥ 2)
        | [ type ]              (list type)
        | ( type )              (parenthesised constructor)
gtycon  → qtycon
        | ()            (unit type)
        | []            (list constructor)
        | (-&gt;)          (function constructor)
        | (,{,})        (tupling constructors) 
</code></pre><h3 id="kind">Kind<a hidden class="anchor" aria-hidden="true" href="#kind">#</a></h3>
<p>What is <code>*</code>, <code>* -&gt; *</code>&hellip;? An ordinary type has kind <code>*</code>. A type constructor
(template) that has one type argument has kind <code>* -&gt; *</code>, e.g. a list. So on and
so forth.</p>
<h3 id="context">Context<a hidden class="anchor" aria-hidden="true" href="#context">#</a></h3>
<p>The context (<code>context =&gt; type</code>) is used to indicate that type <code>tyvar</code> belongs to
class <code>qtycls</code>.</p>
<p>A context is composed of zero or more class assertions.</p>
<pre tabindex="0"><code>context → class
        | ( class1 , … , classn )               (n ≥ 0)
</code></pre><p>And a class assertion is either either a type variable, or the application of
type variable to one or more types.</p>
<pre tabindex="0"><code>class   → qtycls tyvar
        | qtycls ( tyvar atype1 … atypen )      (n ≥ 1)
qtycls  → [ modid . ] tycls
tycls   → conid
tyvar   → varid 
</code></pre><h3 id="algebraic-data-type">Algebraic data type<a hidden class="anchor" aria-hidden="true" href="#algebraic-data-type">#</a></h3>
<p><em>algebraic data type</em> is named so because it is composed of other types by
product and sum (algebraic operations). It introduces a new type constructor
(<code>simpletype</code>) with zero or more constituent data constructors (<code>constrs</code>).</p>
<pre tabindex="0"><code>topdecl → ...
        | data [context =&gt;] simpletype [= constrs] [deriving]
</code></pre><p>The type constructor begins with upper case letter and may have zero to more
type variables as parameters. The type constructor then can be used in curried
type application in a type expression.</p>
<pre tabindex="0"><code>simpletype      → tycon tyvar1 … tyvark         (k ≥ 0) 
</code></pre><p>On the right side of <code>=</code>, sum (alternative) types are separated by <code>|</code>.</p>
<pre tabindex="0"><code>constrs → constr1 | … | constrn         (n ≥ 1)
</code></pre><p>For each <code>constr</code>, there are three alternative syntaxes.</p>
<ol>
<li>A data constructor followed by zero or more <code>atype</code>.</li>
<li>An infix data constructor operator between two <code>btype</code>.</li>
<li>A data constructor followed by field declarations.</li>
</ol>
<pre tabindex="0"><code>constr  → con [!] atype1 … [!] atypek   (arity con  =  k, k ≥ 0)
        | (btype | ! atype) conop (btype | ! atype) (infix conop)
        | con { fielddecl1 , … , fielddecln }       (n ≥ 0) 
con     → conid | ( consym )    (constructor) 
</code></pre><p><code>!</code> is strictness flag to indicate that the corresponding constructor argument
is eagerly evaluated.</p>
<h3 id="type-synonym">Type synonym<a hidden class="anchor" aria-hidden="true" href="#type-synonym">#</a></h3>
<p>A type synonym is equivalent to its definition are completely interchangeable.</p>
<pre tabindex="0"><code>topdecl → type simpletype = type
</code></pre><h3 id="newtype">Newtype<a hidden class="anchor" aria-hidden="true" href="#newtype">#</a></h3>
<p>A <em>newtype</em> declaration introduces a distinct type whose representation is the
same as an existing type.</p>
<pre tabindex="0"><code>topdecl     → newtype [context =&gt;] simpletype = newconstr [deriving]
newconstr   → con atype
            | con { var :: type }
</code></pre><ul>
<li>Unlike type synonyms, <code>newtype</code> may be used to define recursive types.</li>
<li>New instances can be defined for a type defined by <code>newtype</code> but may not be
defined for a type synonym.</li>
<li>A type created by <code>newtype</code> has an extra level of indirection compared to an
algebraic datatype, so the pattern matching rule is different.</li>
</ul>
<h3 id="ad-hoc-polymorphism">Ad hoc polymorphism<a hidden class="anchor" aria-hidden="true" href="#ad-hoc-polymorphism">#</a></h3>
<p>Ad hoc polymorphism (overloading) is supported by <em>typeclasses</em>.</p>
<p>A class declaration introduces a new class and the operations (methods) on it.</p>
<h2 id="modules">Modules<a hidden class="anchor" aria-hidden="true" href="#modules">#</a></h2>
<p><em>To be continued&hellip;</em></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://h12.io/tags/haskell/">Haskell</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>
<footer class="footer">
        <p>&copy; 2012-2025, <span class="my-name">Hǎi-Liàng "Hal" Wáng</span>.</p>
        <p xmlns:cc="http://creativecommons.org/ns#" xmlns:dct="http://purl.org/dc/terms/"><span property="dct:title">The content of this page</span> is licensed under <a href="https://creativecommons.org/licenses/by/4.0/?ref=chooser-v1" target="_blank" rel="license noopener noreferrer" style="display:inline-flex;align-items:center;">CC BY 4.0<img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1" alt=""><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1" alt=""></a></p>
    </footer>


<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
