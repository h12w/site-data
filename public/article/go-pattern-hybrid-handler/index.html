<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Go Pattern: Hybrid Handler | @h12</title>
<meta name="keywords" content="Go, pattern, hybrid runner, runner">
<meta name="description" content="Overview
In today&rsquo;s high-performance and concurrent computing environments, effectively processing a stream of messages using a mix of purely computational functions and remote procedure calls has become a significant challenge. The Go programming language is designed to handle concurrency well, but when it comes to managing a hybrid load, even Go can struggle to achieve optimal CPU utilization. In this article, we will discuss the Hybrid Handler pattern, an efficient and unified approach to address this challenge.">
<meta name="author" content="Hǎi-Liàng &#34;Hal&#34; Wáng">
<link rel="canonical" href="http://h12.io/article/go-pattern-hybrid-handler/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.ef93a538cbae171c70c47408f7fccb878c5ffd285cc92b2b46b10dde0f97f53e.css" integrity="sha256-75OlOMuuFxxwxHQI9/zLh4xf/ShcySsrRrEN3g&#43;X9T4=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://h12.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://h12.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://h12.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://h12.io/apple-touch-icon.png">
<link rel="mask-icon" href="http://h12.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://h12.io/article/go-pattern-hybrid-handler/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">





<link id="syntax-mode" rel="stylesheet" href="/css/syntax-light.css">

<script>
    function isDarkMode() {
        const mode = localStorage.getItem("pref-theme");
        return (mode && mode === "dark") ||
            document.body.className.includes("dark") ||
            false;
    }

    function syncSyntaxMode() {
        document.getElementById("syntax-mode").href = isDarkMode() ? "/css/syntax-dark.css" : "/css/syntax-light.css";
    }

    document.addEventListener("DOMContentLoaded", () => {
        syncSyntaxMode();
        const toggleButton = document.getElementById("theme-toggle");
        if (!toggleButton) {
            console.log("No toggle button found");
            return;
        }
        toggleButton.addEventListener("click", syncSyntaxMode);
    });
</script>

<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$','$$'], ['\\[', '\\]']],
      processEscapes: true,
      processEnvironments: true
    },
    options: {
      enableMenu: false,
      skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
    }
  };
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<meta property="og:url" content="http://h12.io/article/go-pattern-hybrid-handler/">
  <meta property="og:site_name" content="@h12">
  <meta property="og:title" content="Go Pattern: Hybrid Handler">
  <meta property="og:description" content="Overview In today’s high-performance and concurrent computing environments, effectively processing a stream of messages using a mix of purely computational functions and remote procedure calls has become a significant challenge. The Go programming language is designed to handle concurrency well, but when it comes to managing a hybrid load, even Go can struggle to achieve optimal CPU utilization. In this article, we will discuss the Hybrid Handler pattern, an efficient and unified approach to address this challenge.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="article">
    <meta property="article:published_time" content="2023-04-22T17:50:04+01:00">
    <meta property="article:modified_time" content="2023-04-22T17:50:04+01:00">
    <meta property="article:tag" content="Go">
    <meta property="article:tag" content="Pattern">
    <meta property="article:tag" content="Hybrid Runner">
    <meta property="article:tag" content="Runner">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Go Pattern: Hybrid Handler">
<meta name="twitter:description" content="Overview
In today&rsquo;s high-performance and concurrent computing environments, effectively processing a stream of messages using a mix of purely computational functions and remote procedure calls has become a significant challenge. The Go programming language is designed to handle concurrency well, but when it comes to managing a hybrid load, even Go can struggle to achieve optimal CPU utilization. In this article, we will discuss the Hybrid Handler pattern, an efficient and unified approach to address this challenge.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Articles",
      "item": "http://h12.io/article/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Go Pattern: Hybrid Handler",
      "item": "http://h12.io/article/go-pattern-hybrid-handler/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Go Pattern: Hybrid Handler",
  "name": "Go Pattern: Hybrid Handler",
  "description": "Overview In today\u0026rsquo;s high-performance and concurrent computing environments, effectively processing a stream of messages using a mix of purely computational functions and remote procedure calls has become a significant challenge. The Go programming language is designed to handle concurrency well, but when it comes to managing a hybrid load, even Go can struggle to achieve optimal CPU utilization. In this article, we will discuss the Hybrid Handler pattern, an efficient and unified approach to address this challenge.\n",
  "keywords": [
    "Go", "pattern", "hybrid runner", "runner"
  ],
  "articleBody": "Overview In today’s high-performance and concurrent computing environments, effectively processing a stream of messages using a mix of purely computational functions and remote procedure calls has become a significant challenge. The Go programming language is designed to handle concurrency well, but when it comes to managing a hybrid load, even Go can struggle to achieve optimal CPU utilization. In this article, we will discuss the Hybrid Handler pattern, an efficient and unified approach to address this challenge.\nThe problem Assuming we have a stream of incoming messages and we need to process them with a list of handlers, aggregate the results and send the output downstream.\nIf all the handlers are only purely local computations, then an implementation like below already meets the basic functional and performance requirements.\ntype Processor struct { handlers SyncHandler } type SyncHandler interface { Handle(ctx context.Context, message Message) (Result, error) } func (p *Processor) ProcessMessage(ctx context.Context, message Message) error { output := NewOutput() for _, handler := range p.handlers { result, err := handler.Handle(ctx, message) if err != nil { return err } output.Add(result) } return p.SendOutput(output) } e.g. With an 8-core CPU, we can simply initialise 8 Processor objects and run them in 8 goroutines, which can make full use of the hardware easily. (error handling is omitted here)\nfor i := 0; i \u003c numCPU; i++ { go func() { processor := NewProcessor() for message := range inputChan { processor.ProcessMessage(ctx, message) } }() } However, if the processing logic involves a mix of local computations and remote procedure calls, it becomes more difficult to process a high volume of messages in a timely and efficient manner. If the processor still handles messages one by one, it must wait for all handlers to complete before outputting the corresponding result. However, The added I/O roundtrip delay for each message will be so high that the CPU cores stay idle most of the time.\nTo mitigate this issue, one could attempt to saturate the CPU with brute force, parallelizing the processors with even more goroutines, as in most microservices written in Go, where one goroutine is used to handle one incoming request. While this might work well enough for an IO-bound application or when the traffic is low, it can penalize the performance significantly when all or most of the handlers are pure computations due to the relative costs of channel message passing and goroutine scheduling compared to the computations themselves.\nAnother feasible but more ad-hoc solution is just to separate purely computational handlers from remote handlers into two groups, and execute them differently, which could potentially remove the penalty on pure computations. However, how to wait for all the results is still a problem and two separate groups add more complexity to both the start and finish of those functions.\nWhat we need here is an abstraction that unifies local and remote handlers without the overhead of goroutines and channels. This would allow purely computational handlers to achieve bare metal speed while remote handlers don’t block unnecessarily.\nThe Hybrid Handler pattern type Handler interface { Handle( ctx context.Context, message Message, returnResult ReturnResultFunc, ) error type ReturnResultFunc func(ctx context.Context, result Result) error The key to addressing these challenges lies in an interface method that provides a callback parameter returnResult for returning the result, which allows the implementation of the interface to be either a synchronous pure computation or an asynchronous IO operation without introducing much overhead.\nIs it just a function with a callback?\nYes, at first glance, it might look not only trivial but also unidiomatic in Go, but looking closely, we will find that it is a simple and natural solution to the problem at hand and makes a lot of sense.\nThe new processor With the Handler interface above, the Processor can be re-implemented as below.\nOn arrival of each result, the output can decrement a counter atomically to determine if it’s ready to be sent downstream. This operation adds much less overhead than the brute force way of adding many goroutines.\ntype Processor struct { handlers Handler } type Output struct { handlerCount int64 processor *Processor } func (p *Processor) NewOutput(handlerCount int) *Output { return \u0026Output{ HandlerCount: handlerCount, processor: p, } } func (p *Processor) ProcessMessage(ctx context.Context, message Message) error { output := p.NewOutput(len(p.handlers)) for _, handler := range p.handlers { result, err := handler.Handle(ctx, message, output.Add) if err != nil { return err } } return nil } func (o *Output) Add(ctx context.Context, result Result) error // add the result to the output // ...... // check if it's the result of the the last handler if atomic.AddInt64(\u0026h.row.pendingCategories, -1) \u003e 0 { return nil // not the last one } // is the last one return p.processor.SendOutput(o) } Synchronous handlers It is almost trivial to write an adapter from any synchronous handler to the Handler interface above, and the overhead is just one extra interface method call.\ntype SyncHandler interface { Handle(ctx context.Context, message Message) (Result, error) } type SyncHandlerAdapter struct { syncHandler SyncHandler } func (a SyncHandlerAdapter) Handle( ctx context.Context, message Message, returnResult ReturnResultFunc, ) error { result, err := a.syncHandler.Handle(ctx, message) if err != nil { return err } return returnResult(ctx, result) } Asynchronous handlers There are various techniques to wrap a remote procedure call in an asynchronous handler efficiently, e.g. a batch or a streaming API. I do not intend to cover the details here, but regardless of the implementations, the Handler interface allows the Handle method to return immediately without blocking the processing of the next message while a background goroutine can send the result back with the returnResult callback function when the result is ready later.\nA hybrid handler is also possible, returning the result immediately for some inputs while doing it asynchronously for others.\nWe might need to pay more attention to the error handling in the asynchronous handlers. The handler must ensure a result is returned so that the output can decrement the count correctly. So one possible way is to embed the error in the result to be passed back.\nConclusion In conclusion, the Hybrid Handler pattern allows synchronous and asynchronous handlers to coexist without incurring significant overhead, resulting in improved CPU utilization and reduced complexity. By implementing the Hybrid Handler pattern, developers can optimize performance in high-performance computing systems while maintaining the flexibility to handle various types of workloads.\n",
  "wordCount" : "1057",
  "inLanguage": "en",
  "datePublished": "2023-04-22T17:50:04+01:00",
  "dateModified": "2023-04-22T17:50:04+01:00",
  "author":{
    "@type": "Person",
    "name": "Hǎi-Liàng \"Hal\" Wáng"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://h12.io/article/go-pattern-hybrid-handler/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "@h12",
    "logo": {
      "@type": "ImageObject",
      "url": "http://h12.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://h12.io/" accesskey="h" title="@h12 (Alt + H)">@h12</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://h12.io/article/" title="Articles">
                    <span><i class="fas fa-newspaper"></i> Articles</span>
                </a>
            </li>
            <li>
                <a href="http://h12.io/project/" title="Projects">
                    <span><i class="fab fa-github"></i> Projects</span>
                </a>
            </li>
            <li>
                <a href="http://h12.io/note/" title="Notes">
                    <span><i class="fas fa-sticky-note"></i> Notes</span>
                </a>
            </li>
            <li>
                <a href="http://h12.io/about/" title="About">
                    <span><i class="fas fa-user"></i> About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Go Pattern: Hybrid Handler
    </h1>
    <div class="post-meta"><span title='2023-04-22 17:50:04 +0100 BST'>April 22, 2023</span>

</div>
  </header> 
  <div class="post-content"><h2 id="overview">Overview<a hidden class="anchor" aria-hidden="true" href="#overview">#</a></h2>
<p>In today&rsquo;s high-performance and concurrent computing environments, effectively processing a stream of messages using a mix of purely computational functions and remote procedure calls has become a significant challenge. The Go programming language is designed to handle concurrency well, but when it comes to managing a hybrid load, even Go can struggle to achieve optimal CPU utilization. In this article, we will discuss the Hybrid Handler pattern, an efficient and unified approach to address this challenge.</p>
<h2 id="the-problem">The problem<a hidden class="anchor" aria-hidden="true" href="#the-problem">#</a></h2>
<p>Assuming we have a stream of incoming messages and we need to process them with a list of handlers, aggregate the results and send the output downstream.</p>
<p>If all the handlers are only purely local computations, then an implementation like below already meets the basic functional and performance requirements.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Processor</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">handlers</span> <span class="nx">SyncHandler</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">SyncHandler</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Handle</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">message</span> <span class="nx">Message</span><span class="p">)</span> <span class="p">(</span><span class="nx">Result</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Processor</span><span class="p">)</span> <span class="nf">ProcessMessage</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">message</span> <span class="nx">Message</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">output</span> <span class="o">:=</span> <span class="nf">NewOutput</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">handler</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">p</span><span class="p">.</span><span class="nx">handlers</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">result</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">handler</span><span class="p">.</span><span class="nf">Handle</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">message</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">output</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nf">SendOutput</span><span class="p">(</span><span class="nx">output</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>e.g. With an 8-core CPU, we can simply initialise 8 <code>Processor</code> objects and run them in 8 goroutines, which can make full use of the hardware easily. (error handling is omitted here)</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">numCPU</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">processor</span> <span class="o">:=</span> <span class="nf">NewProcessor</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nx">message</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">inputChan</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">processor</span><span class="p">.</span><span class="nf">ProcessMessage</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">message</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>However, if the processing logic involves a mix of local computations and remote procedure calls, it becomes more difficult to process a high volume of messages in a timely and efficient manner. If the processor still handles messages one by one, it must wait for all handlers to complete before outputting the corresponding result. However, The added I/O roundtrip delay for each message will be so high that the CPU cores stay idle most of the time.</p>
<p>To mitigate this issue, one could attempt to saturate the CPU with brute force, parallelizing the processors with even more goroutines, as in most microservices written in Go, where one goroutine is used to handle one incoming request. While this might work well enough for an IO-bound application or when the traffic is low, it can penalize the performance significantly when all or most of the handlers are pure computations due to the relative costs of channel message passing and goroutine scheduling compared to the computations themselves.</p>
<p>Another feasible but more ad-hoc solution is just to separate purely computational handlers from remote handlers into two groups, and execute them differently, which could potentially remove the penalty on pure computations. However, how to wait for all the results is still a problem and two separate groups add more complexity to both the start and finish of those functions.</p>
<p>What we need here is an abstraction that unifies local and remote handlers without the overhead of goroutines and channels. This would allow purely computational handlers to achieve bare metal speed while remote handlers don&rsquo;t block unnecessarily.</p>
<h2 id="the-hybrid-handler-pattern">The Hybrid Handler pattern<a hidden class="anchor" aria-hidden="true" href="#the-hybrid-handler-pattern">#</a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Handler</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Handle</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="nx">ctx</span>          <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">message</span>      <span class="nx">Message</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">returnResult</span> <span class="nx">ReturnResultFunc</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">ReturnResultFunc</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">result</span> <span class="nx">Result</span><span class="p">)</span> <span class="kt">error</span>
</span></span></code></pre></div><p>The key to addressing these challenges lies in an interface method that provides a callback parameter <code>returnResult</code> for returning the result, which allows the implementation of the interface to be either a synchronous pure computation or an asynchronous IO operation without introducing much overhead.</p>
<p>Is it just a function with a callback?</p>
<p>Yes, at first glance, it might look not only trivial but also unidiomatic in Go, but looking closely, we will find that it is a simple and natural solution to the problem at hand and makes a lot of sense.</p>
<h2 id="the-new-processor">The new processor<a hidden class="anchor" aria-hidden="true" href="#the-new-processor">#</a></h2>
<p>With the <code>Handler</code> interface above, the <code>Processor</code> can be re-implemented as below.</p>
<p>On arrival of each result, the output can decrement a counter atomically to determine if it&rsquo;s ready to be sent downstream. This operation adds much less overhead than the brute force way of adding many goroutines.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Processor</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">handlers</span> <span class="nx">Handler</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Output</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">handlerCount</span> <span class="kt">int64</span>
</span></span><span class="line"><span class="cl">    <span class="nx">processor</span> <span class="o">*</span><span class="nx">Processor</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Processor</span><span class="p">)</span> <span class="nf">NewOutput</span><span class="p">(</span><span class="nx">handlerCount</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">Output</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">Output</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">HandlerCount</span><span class="p">:</span> <span class="nx">handlerCount</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">processor</span><span class="p">:</span>    <span class="nx">p</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Processor</span><span class="p">)</span> <span class="nf">ProcessMessage</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">message</span> <span class="nx">Message</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">output</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">NewOutput</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">handlers</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">handler</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">p</span><span class="p">.</span><span class="nx">handlers</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">result</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">handler</span><span class="p">.</span><span class="nf">Handle</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">message</span><span class="p">,</span> <span class="nx">output</span><span class="p">.</span><span class="nx">Add</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">Output</span><span class="p">)</span> <span class="nf">Add</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">result</span> <span class="nx">Result</span><span class="p">)</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// add the result to the output</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// check if it&#39;s the result of the the last handler</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">AddInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">row</span><span class="p">.</span><span class="nx">pendingCategories</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span> <span class="c1">// not the last one</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// is the last one</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">processor</span><span class="p">.</span><span class="nf">SendOutput</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="synchronous-handlers">Synchronous handlers<a hidden class="anchor" aria-hidden="true" href="#synchronous-handlers">#</a></h2>
<p>It is almost trivial to write an adapter from any synchronous handler to the <code>Handler</code> interface above, and the overhead is just one extra interface method call.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">SyncHandler</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Handle</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">message</span> <span class="nx">Message</span><span class="p">)</span> <span class="p">(</span><span class="nx">Result</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">SyncHandlerAdapter</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">syncHandler</span> <span class="nx">SyncHandler</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="nx">SyncHandlerAdapter</span><span class="p">)</span> <span class="nf">Handle</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ctx</span>          <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">message</span>      <span class="nx">Message</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">returnResult</span> <span class="nx">ReturnResultFunc</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">result</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">syncHandler</span><span class="p">.</span><span class="nf">Handle</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">message</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">returnResult</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">result</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="asynchronous-handlers">Asynchronous handlers<a hidden class="anchor" aria-hidden="true" href="#asynchronous-handlers">#</a></h2>
<p>There are various techniques to wrap a remote procedure call in an asynchronous handler efficiently, e.g. a batch or a streaming API. I do not intend to cover the details here, but regardless of the implementations, the <code>Handler</code> interface allows the Handle method to return immediately without blocking the processing of the next message while a background goroutine can send the result back with the <code>returnResult</code> callback function when the result is ready later.</p>
<p>A hybrid handler is also possible, returning the result immediately for some inputs while doing it asynchronously for others.</p>
<p>We might need to pay more attention to the error handling in the asynchronous handlers. The handler must ensure a result is returned so that the output can decrement the count correctly. So one possible way is to embed the error in the result to be passed back.</p>
<h2 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h2>
<p>In conclusion, the Hybrid Handler pattern allows synchronous and asynchronous handlers to coexist without incurring significant overhead, resulting in improved CPU utilization and reduced complexity. By implementing the Hybrid Handler pattern, developers can optimize performance in high-performance computing systems while maintaining the flexibility to handle various types of workloads.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://h12.io/tags/go/">Go</a></li>
      <li><a href="http://h12.io/tags/pattern/">Pattern</a></li>
      <li><a href="http://h12.io/tags/hybrid-runner/">Hybrid Runner</a></li>
      <li><a href="http://h12.io/tags/runner/">Runner</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a><footer class="footer">
        <p>&copy; 2012-2025, <span class="my-name">Hǎi-Liàng "Hal" Wáng</span>.</p>
        <p xmlns:cc="http://creativecommons.org/ns#" xmlns:dct="http://purl.org/dc/terms/"><span property="dct:title">The content of this page</span> is licensed under <a href="https://creativecommons.org/licenses/by/4.0/?ref=chooser-v1" target="_blank" rel="license noopener noreferrer" style="display:inline-flex;align-items:center;">CC BY 4.0<img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1" alt=""><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1" alt=""></a></p>
    </footer>


<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
